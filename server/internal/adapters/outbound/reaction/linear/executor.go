package linear

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	areadomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/area"
	componentdomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/component"
	identitydomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/identity"
	"github.com/Epitech-2nd-Year-Projects/AREA/server/internal/ports/outbound"
	identityport "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/ports/outbound/identity"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

const (
	linearProviderName        = "linear"
	createIssueComponentName  = "linear_create_issue"
	linearGraphQLEndpoint     = "https://api.linear.app/graphql"
	linearGeneratedMarker     = "<-- AREA_LINEAR_AUTOGENERATED -->"
	linearDescriptionMaxRunes = 2000
)

// ProviderResolver exposes OAuth providers by name
type ProviderResolver interface {
	Provider(name string) (identityport.Provider, bool)
}

// HTTPClient models the subset of http.Client used by the executor
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// Clock abstracts time retrieval for deterministic tests
type Clock interface {
	Now() time.Time
}

type systemClock struct{}

func (systemClock) Now() time.Time {
	return time.Now().UTC()
}

// IssueExecutor delivers Linear reactions that create issues
type IssueExecutor struct {
	identities identityport.Repository
	providers  ProviderResolver
	http       HTTPClient
	clock      Clock
	logger     *zap.Logger
}

// NewIssueExecutor constructs an IssueExecutor from its dependencies
func NewIssueExecutor(identities identityport.Repository, providers ProviderResolver, client HTTPClient, clock Clock, logger *zap.Logger) *IssueExecutor {
	if client == nil {
		client = http.DefaultClient
	}
	if clock == nil {
		clock = systemClock{}
	}
	if logger == nil {
		logger = zap.NewNop()
	}
	return &IssueExecutor{
		identities: identities,
		providers:  providers,
		http:       client,
		clock:      clock,
		logger:     logger,
	}
}

// Supports reports whether the executor can handle the provided component
func (e *IssueExecutor) Supports(component *componentdomain.Component) bool {
	if component == nil || component.Provider.Name == "" {
		return false
	}
	return strings.EqualFold(component.Name, createIssueComponentName) &&
		strings.EqualFold(component.Provider.Name, linearProviderName)
}

// Execute creates a Linear issue using the linked identity
func (e *IssueExecutor) Execute(ctx context.Context, area areadomain.Area, link areadomain.Link) (outbound.ReactionResult, error) {
	if !e.Supports(link.Config.Component) {
		return outbound.ReactionResult{}, fmt.Errorf("linear.IssueExecutor: unsupported component")
	}
	if e.identities == nil || e.providers == nil {
		return outbound.ReactionResult{}, fmt.Errorf("linear.IssueExecutor: resolver not configured")
	}

	cfg, err := parseIssueConfig(link.Config.Params)
	if err != nil {
		return outbound.ReactionResult{}, fmt.Errorf("linear.IssueExecutor: %w", err)
	}

	identity, err := e.identities.FindByID(ctx, cfg.identityID)
	if err != nil {
		return outbound.ReactionResult{}, fmt.Errorf("linear.IssueExecutor: identity lookup: %w", err)
	}
	if identity.UserID != area.UserID {
		return outbound.ReactionResult{}, fmt.Errorf("linear.IssueExecutor: identity not owned by user")
	}

	identity, accessToken, err := e.ensureAccessToken(ctx, identity, false)
	if err != nil {
		return outbound.ReactionResult{}, err
	}

	result, unauthorized, err := e.createIssue(ctx, accessToken, cfg)
	if err != nil && unauthorized {
		identity, accessToken, err = e.ensureAccessToken(ctx, identity, true)
		if err != nil {
			return outbound.ReactionResult{}, err
		}
		result, unauthorized, err = e.createIssue(ctx, accessToken, cfg)
	}
	if err != nil {
		return result, err
	}
	if unauthorized {
		return result, fmt.Errorf("linear.IssueExecutor: unauthorized after refresh")
	}

	e.logger.Info("linear issue created",
		zap.String("area_id", area.ID.String()),
		zap.String("identity_id", identity.ID.String()),
		zap.String("team_id", cfg.teamID),
	)
	return result, nil
}

func (e *IssueExecutor) createIssue(ctx context.Context, accessToken string, cfg issueConfig) (outbound.ReactionResult, bool, error) {
	payload := map[string]any{
		"query": "mutation IssueCreate($input: IssueCreateInput!) { issueCreate(input: $input) { success issue { id identifier url } } }",
		"variables": map[string]any{
			"input": map[string]any{
				"teamId": cfg.teamID,
				"title":  cfg.title,
			},
		},
	}

	input := payload["variables"].(map[string]any)["input"].(map[string]any)
	description := decorateLinearDescription(cfg.description)
	if description != "" {
		input["description"] = description
	}
	if cfg.priority != nil {
		input["priority"] = *cfg.priority
	}

	bodyBytes, err := json.Marshal(payload)
	if err != nil {
		return outbound.ReactionResult{}, false, fmt.Errorf("linear.IssueExecutor: marshal payload: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, linearGraphQLEndpoint, bytes.NewReader(bodyBytes))
	if err != nil {
		return outbound.ReactionResult{}, false, fmt.Errorf("linear.IssueExecutor: build request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+accessToken)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("User-Agent", "AREA-Server")

	start := time.Now()
	resp, err := e.http.Do(req)
	if err != nil {
		return outbound.ReactionResult{}, false, fmt.Errorf("linear.IssueExecutor: request failed: %w", err)
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	duration := time.Since(start)

	requestHeaders := copyHeaders(req.Header)
	responseHeaders := copyHeaders(resp.Header)

	result := outbound.ReactionResult{
		Endpoint: linearGraphQLEndpoint,
		Request: map[string]any{
			"method":  http.MethodPost,
			"url":     linearGraphQLEndpoint,
			"headers": requestHeaders,
			"body":    string(bodyBytes),
		},
		Response: map[string]any{
			"body":    string(respBody),
			"headers": responseHeaders,
		},
		StatusCode: &resp.StatusCode,
		Duration:   duration,
	}

	if resp.StatusCode >= 400 {
		if resp.StatusCode == http.StatusUnauthorized || resp.StatusCode == http.StatusForbidden {
			return result, true, fmt.Errorf("linear.IssueExecutor: received status %d", resp.StatusCode)
		}
		return result, false, fmt.Errorf("linear.IssueExecutor: received status %d", resp.StatusCode)
	}

	var gqlResp struct {
		Data struct {
			IssueCreate struct {
				Success bool `json:"success"`
			} `json:"issueCreate"`
		} `json:"data"`
		Errors []struct {
			Message string `json:"message"`
		} `json:"errors"`
	}
	if err := json.Unmarshal(respBody, &gqlResp); err != nil {
		return result, false, fmt.Errorf("linear.IssueExecutor: decode response: %w", err)
	}
	if len(gqlResp.Errors) > 0 {
		messages := make([]string, 0, len(gqlResp.Errors))
		for _, entry := range gqlResp.Errors {
			if trimmed := strings.TrimSpace(entry.Message); trimmed != "" {
				messages = append(messages, trimmed)
			}
		}
		if len(messages) == 0 {
			messages = append(messages, "graphQL errors present")
		}
		return result, false, fmt.Errorf("linear.IssueExecutor: %s", strings.Join(messages, "; "))
	}
	if !gqlResp.Data.IssueCreate.Success {
		return result, false, fmt.Errorf("linear.IssueExecutor: create issue not successful")
	}

	return result, false, nil
}

func (e *IssueExecutor) ensureAccessToken(ctx context.Context, identity identitydomain.Identity, force bool) (identitydomain.Identity, string, error) {
	now := e.now()
	if identity.AccessToken != "" && !force && !identity.TokenExpired(now) {
		return identity, identity.AccessToken, nil
	}

	provider, ok := e.providers.Provider(linearProviderName)
	if !ok {
		return identity, "", fmt.Errorf("linear.IssueExecutor: provider %s not configured", linearProviderName)
	}

	exchange, err := provider.Refresh(ctx, identity)
	if err != nil {
		return identity, "", fmt.Errorf("linear.IssueExecutor: refresh token: %w", err)
	}

	refreshToken := exchange.Token.RefreshToken
	if refreshToken == "" {
		refreshToken = identity.RefreshToken
	}
	expiresAt := identity.ExpiresAt
	if !exchange.Token.ExpiresAt.IsZero() {
		expires := exchange.Token.ExpiresAt.UTC()
		expiresAt = &expires
	}
	scopes := exchange.Token.Scope
	if len(scopes) == 0 {
		scopes = identity.Scopes
	}

	updated := identity.WithTokens(exchange.Token.AccessToken, refreshToken, expiresAt, scopes)
	updated.UpdatedAt = now

	if err := e.identities.Update(ctx, updated); err != nil {
		return identity, "", fmt.Errorf("linear.IssueExecutor: update identity: %w", err)
	}

	return updated, updated.AccessToken, nil
}

func (e *IssueExecutor) now() time.Time {
	if e.clock == nil {
		return time.Now().UTC()
	}
	return e.clock.Now().UTC()
}

type issueConfig struct {
	identityID  uuid.UUID
	teamID      string
	title       string
	description string
	priority    *int
}

func parseIssueConfig(params map[string]any) (issueConfig, error) {
	var cfg issueConfig
	if params == nil {
		return cfg, fmt.Errorf("parse issue config: params missing")
	}

	rawIdentity, ok := params["identityId"]
	if !ok {
		return cfg, fmt.Errorf("parse issue config: identityId missing")
	}
	identityStr, err := toString(rawIdentity)
	if err != nil {
		return cfg, fmt.Errorf("parse issue config: identityId invalid: %w", err)
	}
	identityID, err := uuid.Parse(strings.TrimSpace(identityStr))
	if err != nil {
		return cfg, fmt.Errorf("parse issue config: identityId parse: %w", err)
	}
	cfg.identityID = identityID

	teamID, err := requiredTrimmedString(params, "teamId")
	if err != nil {
		return cfg, err
	}
	cfg.teamID = teamID

	title, err := requiredTrimmedString(params, "title")
	if err != nil {
		return cfg, err
	}
	cfg.title = title

	description, err := optionalString(params, "description")
	if err != nil {
		return cfg, fmt.Errorf("parse issue config: description invalid: %w", err)
	}
	cfg.description = description

	priority, err := optionalPriority(params, "priority", 0, 4)
	if err != nil {
		return cfg, fmt.Errorf("parse issue config: priority invalid: %w", err)
	}
	cfg.priority = priority

	return cfg, nil
}

func requiredTrimmedString(params map[string]any, key string) (string, error) {
	value, ok := params[key]
	if !ok {
		return "", fmt.Errorf("parse issue config: %s missing", key)
	}
	raw, err := toString(value)
	if err != nil {
		return "", fmt.Errorf("parse issue config: %s invalid: %w", key, err)
	}
	trimmed := strings.TrimSpace(raw)
	if trimmed == "" {
		return "", fmt.Errorf("parse issue config: %s empty", key)
	}
	return trimmed, nil
}

func optionalString(params map[string]any, key string) (string, error) {
	value, ok := params[key]
	if !ok || value == nil {
		return "", nil
	}
	raw, err := toString(value)
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(raw), nil
}

func optionalPriority(params map[string]any, key string, min, max int) (*int, error) {
	value, ok := params[key]
	if !ok || value == nil {
		return nil, nil
	}

	if str, isString := value.(string); isString {
		trimmed := strings.TrimSpace(str)
		if trimmed == "" {
			return nil, nil
		}
		value = trimmed
	}

	number, err := toInt(value)
	if err != nil {
		return nil, err
	}
	if number < min || number > max {
		return nil, fmt.Errorf("priority out of bounds")
	}
	return &number, nil
}

func decorateLinearDescription(source string) string {
	trimmed := strings.TrimSpace(source)
	if trimmed == "" {
		return linearGeneratedMarker
	}
	if strings.Contains(trimmed, linearGeneratedMarker) {
		return trimmed
	}
	marker := "\n\n" + linearGeneratedMarker
	markerLen := len([]rune(marker))
	descriptionRunes := []rune(trimmed)
	if len(descriptionRunes)+markerLen <= linearDescriptionMaxRunes {
		return trimmed + marker
	}
	available := linearDescriptionMaxRunes - markerLen
	if available <= 0 {
		return linearGeneratedMarker
	}
	if len(descriptionRunes) > available {
		descriptionRunes = descriptionRunes[:available]
	}
	trimmed = strings.TrimRight(string(descriptionRunes), " \t\r\n")
	if trimmed == "" {
		return linearGeneratedMarker
	}
	if len([]rune(trimmed))+markerLen > linearDescriptionMaxRunes {
		limit := linearDescriptionMaxRunes - markerLen
		if limit <= 0 {
			return linearGeneratedMarker
		}
		runes := []rune(trimmed)
		if len(runes) > limit {
			trimmed = strings.TrimRight(string(runes[:limit]), " \t\r\n")
			if trimmed == "" {
				return linearGeneratedMarker
			}
		}
	}
	return trimmed + marker
}

func toString(value any) (string, error) {
	switch v := value.(type) {
	case string:
		return v, nil
	case fmt.Stringer:
		return v.String(), nil
	default:
		return "", fmt.Errorf("expected string got %T", value)
	}
}

func toInt(value any) (int, error) {
	switch v := value.(type) {
	case int:
		return v, nil
	case int64:
		return int(v), nil
	case float64:
		return int(v), nil
	case json.Number:
		parsed, err := v.Int64()
		if err != nil {
			return 0, fmt.Errorf("unexpected number: %w", err)
		}
		return int(parsed), nil
	case string:
		trimmed := strings.TrimSpace(v)
		if trimmed == "" {
			return 0, fmt.Errorf("empty string")
		}
		parsed, err := strconv.Atoi(trimmed)
		if err != nil {
			return 0, fmt.Errorf("unexpected string: %w", err)
		}
		return parsed, nil
	default:
		return 0, fmt.Errorf("unexpected type %T", value)
	}
}

func copyHeaders(headers http.Header) map[string][]string {
	copied := make(map[string][]string, len(headers))
	for key, values := range headers {
		copied[key] = append([]string(nil), values...)
	}
	return copied
}

// Ensure IssueExecutor satisfies the ComponentReactionHandler contract
var _ interface {
	Supports(*componentdomain.Component) bool
	Execute(context.Context, areadomain.Area, areadomain.Link) (outbound.ReactionResult, error)
} = (*IssueExecutor)(nil)
