package auth

import (
	"errors"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/Epitech-2nd-Year-Projects/AREA/server/internal/adapters/inbound/http/openapi"
	identitydomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/identity"
	sessiondomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/session"
	subscriptiondomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/subscription"
	userdomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/user"
	identityport "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/ports/outbound/identity"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	openapitypes "github.com/oapi-codegen/runtime/types"
)

// CookieConfig encapsulates browser cookie attributes enforced by the handler
type CookieConfig struct {
	Domain   string
	Path     string
	Secure   bool
	HTTPOnly bool
	SameSite http.SameSite
}

// Handler exposes authentication endpoints backed by Service
// Use Register to mount the handler on the gin engine generated by oapi-codegen
type Handler struct {
	service *Service
	oauth   *OAuthService
	cookies CookieConfig
}

// NewHandler constructs the HTTP handler
func NewHandler(service *Service, oauth *OAuthService, cookies CookieConfig) *Handler {
	if cookies.Path == "" {
		cookies.Path = "/"
	}
	return &Handler{service: service, oauth: oauth, cookies: cookies}
}

// RegisterUser handles POST /v1/users
func (h *Handler) RegisterUser(c *gin.Context) {
	var payload openapi.RegisterUserRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	result, err := h.service.Register(c.Request.Context(), string(payload.Email), payload.Password)
	if err != nil {
		switch {
		case errors.Is(err, ErrEmailAlreadyRegistered):
			c.JSON(http.StatusConflict, gin.H{"error": "email already registered"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "unable to register"})
			return
		}
	}

	expiresAt := result.VerificationExpires.UTC()
	response := openapi.RegisterUserResponse{
		ExpiresAt: expiresAt,
		UserId:    result.User.ID.String(),
	}
	c.JSON(http.StatusAccepted, response)
}

// VerifyEmail handles POST /v1/auth/verify
func (h *Handler) VerifyEmail(c *gin.Context) {
	token := strings.TrimSpace(c.Query("token"))
	if token == "" && c.Request.Method != http.MethodGet {
		var payload openapi.VerifyEmailRequest
		if err := c.ShouldBindJSON(&payload); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
			return
		}
		token = strings.TrimSpace(payload.Token)
	}
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
		return
	}

	result, err := h.service.VerifyEmail(c.Request.Context(), token, h.requestMetadata(c))
	if err != nil {
		switch {
		case errors.Is(err, ErrVerificationTokenExpired), errors.Is(err, ErrVerificationTokenUsed):
			c.JSON(http.StatusGone, gin.H{"error": "token invalid"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "verification failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	response := toAuthSessionResponse(result.User, result.Session)
	c.JSON(http.StatusOK, response)
}

// Login handles POST /v1/auth/login
func (h *Handler) Login(c *gin.Context) {
	var payload openapi.LoginRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
		return
	}

	result, err := h.service.Login(c.Request.Context(), string(payload.Email), payload.Password, h.requestMetadata(c))
	if err != nil {
		switch {
		case errors.Is(err, ErrInvalidCredentials):
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
			return
		case errors.Is(err, ErrAccountNotVerified):
			c.JSON(http.StatusForbidden, gin.H{"error": "account not verified"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "authentication failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	response := toAuthSessionResponse(result.User, result.Session)
	c.JSON(http.StatusOK, response)
}

// Logout handles POST /v1/auth/logout
func (h *Handler) Logout(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	if err := h.service.Logout(c.Request.Context(), sessionID); err != nil {
		h.clearSessionCookie(c)
		if errors.Is(err, ErrSessionNotFound) {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to revoke session"})
		return
	}

	h.clearSessionCookie(c)
	c.Status(http.StatusNoContent)
}

// GetCurrentUser handles GET /v1/auth/me
func (h *Handler) GetCurrentUser(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	h.refreshSessionCookie(c, sess)
	c.JSON(http.StatusOK, openapi.UserResponse{User: toOpenAPIUser(usr)})
}

// ListIdentities handles GET /v1/identities
func (h *Handler) ListIdentities(c *gin.Context) {
	if h.oauth == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "oauth not configured"})
		return
	}

	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	h.refreshSessionCookie(c, sess)

	items, err := h.oauth.ListIdentities(c.Request.Context(), usr.ID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list identities"})
		return
	}

	response := openapi.IdentityListResponse{Identities: mapIdentities(items)}
	c.JSON(http.StatusOK, response)
}

// AuthorizeOAuth handles POST /v1/oauth/{provider}/authorize
func (h *Handler) AuthorizeOAuth(c *gin.Context, provider string) {
	if h.oauth == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	var payload openapi.OAuthAuthorizationRequest
	if err := c.ShouldBindJSON(&payload); err != nil && !errors.Is(err, io.EOF) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	req := identityport.AuthorizationRequest{
		RedirectURI: stringValue(payload.RedirectUri),
		State:       stringValue(payload.State),
		Prompt:      stringValue(payload.Prompt),
		UsePKCE:     true,
	}
	if payload.UsePkce != nil {
		req.UsePKCE = *payload.UsePkce
	}
	if payload.Scopes != nil {
		req.Scopes = append([]string(nil), *payload.Scopes...)
	}

	resp, err := h.oauth.AuthorizationURL(c.Request.Context(), provider, req)
	if err != nil {
		h.handleOAuthError(c, err)
		return
	}

	response := openapi.OAuthAuthorizationResponse{
		AuthorizationUrl: resp.AuthorizationURL,
	}
	if resp.State != "" {
		response.State = &resp.State
	}
	if resp.CodeVerifier != "" {
		response.CodeVerifier = &resp.CodeVerifier
	}
	if resp.CodeChallenge != "" {
		response.CodeChallenge = &resp.CodeChallenge
	}
	if resp.CodeChallengeMethod != "" {
		method := string(resp.CodeChallengeMethod)
		response.CodeChallengeMethod = &method
	}

	c.JSON(http.StatusOK, response)
}

// ExchangeOAuth handles POST /v1/oauth/{provider}/exchange
func (h *Handler) ExchangeOAuth(c *gin.Context, provider string) {
	if h.oauth == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	var payload openapi.OAuthExchangeRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	code := strings.TrimSpace(payload.Code)
	if code == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "code is required"})
		return
	}

	req := identityport.ExchangeRequest{
		RedirectURI:  stringValue(payload.RedirectUri),
		CodeVerifier: stringValue(payload.CodeVerifier),
	}

	result, _, err := h.oauth.Exchange(c.Request.Context(), provider, code, req, h.requestMetadata(c))
	if err != nil {
		h.handleOAuthError(c, err)
		return
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	response := toAuthSessionResponse(result.User, result.Session)
	c.JSON(http.StatusOK, response)
}

// SubscribeService handles POST /v1/services/{provider}/subscribe
func (h *Handler) SubscribeService(c *gin.Context, provider string) {
	if h.oauth == nil || h.service == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	var payload openapi.SubscribeServiceRequest
	if err := c.ShouldBindJSON(&payload); err != nil && !errors.Is(err, io.EOF) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	req := identityport.AuthorizationRequest{
		RedirectURI: stringValue(payload.RedirectUri),
		State:       stringValue(payload.State),
		Prompt:      stringValue(payload.Prompt),
		UsePKCE:     true,
	}
	if payload.UsePkce != nil {
		req.UsePKCE = *payload.UsePkce
	}
	if payload.Scopes != nil {
		req.Scopes = append([]string(nil), *payload.Scopes...)
	}

	result, err := h.oauth.BeginSubscription(c.Request.Context(), usr, provider, req)
	if err != nil {
		h.handleSubscriptionError(c, err)
		return
	}

	h.refreshSessionCookie(c, sess)

	if result.Authorization != nil {
		authorization := toOpenAPIAuthorizationResponse(*result.Authorization)
		resp := openapi.SubscribeServiceResponse{
			Status:        "authorization_required",
			Authorization: &authorization,
		}
		c.JSON(http.StatusOK, resp)
		return
	}

	if result.Subscription != nil {
		summary := toOpenAPISubscription(*result.Subscription)
		resp := openapi.SubscribeServiceResponse{
			Status:       "subscribed",
			Subscription: &summary,
		}
		c.JSON(http.StatusOK, resp)
		return
	}

	c.JSON(http.StatusInternalServerError, gin.H{"error": "subscription initialization failed"})
}

// SubscribeServiceExchange handles POST /v1/services/{provider}/subscribe/exchange
func (h *Handler) SubscribeServiceExchange(c *gin.Context, provider string) {
	if h.oauth == nil || h.service == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	var payload openapi.SubscribeExchangeRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	code := strings.TrimSpace(payload.Code)
	if code == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "code is required"})
		return
	}

	req := identityport.ExchangeRequest{
		RedirectURI:  stringValue(payload.RedirectUri),
		CodeVerifier: stringValue(payload.CodeVerifier),
	}

	subscription, identity, err := h.oauth.CompleteSubscription(c.Request.Context(), usr, provider, code, req)
	if err != nil {
		h.handleSubscriptionError(c, err)
		return
	}

	h.refreshSessionCookie(c, sess)

	resp := openapi.SubscribeExchangeResponse{
		Subscription: toOpenAPISubscription(subscription),
	}
	if identity.ID != uuid.Nil {
		identitySummary := toOpenAPIIdentity(identity)
		resp.Identity = &identitySummary
	}

	c.JSON(http.StatusOK, resp)
}

func (h *Handler) setSessionCookie(c *gin.Context, name string, sess sessiondomain.Session) {
	maxAge := int(time.Until(sess.ExpiresAt).Seconds())
	if maxAge <= 0 {
		maxAge = 0
	}
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(name, sess.ID.String(), maxAge, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) refreshSessionCookie(c *gin.Context, sess sessiondomain.Session) {
	h.setSessionCookie(c, h.service.cfg.CookieName, sess)
}

func (h *Handler) clearSessionCookie(c *gin.Context) {
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(h.service.cfg.CookieName, "", -1, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) sessionIDFromCookie(c *gin.Context) uuid.UUID {
	value, err := c.Cookie(h.service.cfg.CookieName)
	if err != nil {
		return uuid.Nil
	}
	id, err := uuid.Parse(value)
	if err != nil {
		return uuid.Nil
	}
	return id
}

func (h *Handler) requestMetadata(c *gin.Context) Metadata {
	return Metadata{
		ClientIP:  c.ClientIP(),
		UserAgent: c.Request.UserAgent(),
	}
}

func (h *Handler) handleOAuthError(c *gin.Context, err error) {
	switch {
	case err == nil:
		c.Status(http.StatusInternalServerError)
	case errors.Is(err, ErrProviderNotConfigured):
		c.JSON(http.StatusNotFound, gin.H{"error": "provider not configured"})
	case errors.Is(err, ErrOAuthEmailMissing):
		c.JSON(http.StatusBadRequest, gin.H{"error": "email missing from provider"})
	case errors.Is(err, ErrIdentityOwnershipConflict):
		c.JSON(http.StatusConflict, gin.H{"error": "identity already linked"})
	default:
		c.JSON(http.StatusBadGateway, gin.H{"error": "oauth provider error"})
	}
}

func (h *Handler) handleSubscriptionError(c *gin.Context, err error) {
	switch {
	case err == nil:
		c.Status(http.StatusInternalServerError)
	case errors.Is(err, ErrProviderNotConfigured):
		c.JSON(http.StatusNotFound, gin.H{"error": "provider not configured"})
	case errors.Is(err, ErrIdentityOwnershipConflict):
		c.JSON(http.StatusConflict, gin.H{"error": "identity already linked"})
	case errors.Is(err, ErrSubscriptionNotSupported):
		c.JSON(http.StatusBadRequest, gin.H{"error": "subscription not supported"})
	case errors.Is(err, ErrOAuthEmailMissing):
		c.JSON(http.StatusBadRequest, gin.H{"error": "email missing from provider"})
	default:
		c.JSON(http.StatusBadGateway, gin.H{"error": "oauth provider error"})
	}
}

func stringValue(value *string) string {
	if value == nil {
		return ""
	}
	return strings.TrimSpace(*value)
}

func toOpenAPIUser(u userdomain.User) openapi.User {
	return openapi.User{
		Id:          u.ID,
		Email:       openapitypes.Email(u.Email),
		Status:      string(u.Status),
		CreatedAt:   u.CreatedAt,
		UpdatedAt:   u.UpdatedAt,
		LastLoginAt: u.LastLoginAt,
	}
}

func toAuthSessionResponse(user userdomain.User, session sessiondomain.Session) openapi.AuthSessionResponse {
	expiresAt := session.ExpiresAt.UTC()
	tokenType := "session"
	return openapi.AuthSessionResponse{
		User:      toOpenAPIUser(user),
		ExpiresAt: &expiresAt,
		TokenType: &tokenType,
	}
}

func mapIdentities(items []identitydomain.Identity) []openapi.IdentitySummary {
	if len(items) == 0 {
		return make([]openapi.IdentitySummary, 0)
	}
	result := make([]openapi.IdentitySummary, 0, len(items))
	for _, item := range items {
		result = append(result, toOpenAPIIdentity(item))
	}
	return result
}

func toOpenAPIIdentity(identity identitydomain.Identity) openapi.IdentitySummary {
	scopesCopy := append([]string(nil), identity.Scopes...)

	var scopesPtr *[]string
	if len(scopesCopy) > 0 {
		scopesPtr = &scopesCopy
	}

	var expiresAt *time.Time
	if identity.ExpiresAt != nil {
		expiry := identity.ExpiresAt.UTC()
		expiresAt = &expiry
	}

	return openapi.IdentitySummary{
		Id:          identity.ID,
		Provider:    identity.Provider,
		Subject:     identity.Subject,
		Scopes:      scopesPtr,
		ConnectedAt: identity.CreatedAt.UTC(),
		ExpiresAt:   expiresAt,
	}
}

func toOpenAPISubscription(subscription subscriptiondomain.Subscription) openapi.SubscriptionSummary {
	var identityID *openapitypes.UUID
	if subscription.IdentityID != nil {
		id := openapitypes.UUID(*subscription.IdentityID)
		identityID = &id
	}

	var scopeGrants *[]string
	if len(subscription.ScopeGrants) > 0 {
		copyScopes := append([]string(nil), subscription.ScopeGrants...)
		scopeGrants = &copyScopes
	}

	return openapi.SubscriptionSummary{
		Id:          subscription.ID,
		ProviderId:  subscription.ProviderID,
		IdentityId:  identityID,
		Status:      string(subscription.Status),
		ScopeGrants: scopeGrants,
		CreatedAt:   subscription.CreatedAt.UTC(),
		UpdatedAt:   subscription.UpdatedAt.UTC(),
	}
}

func toOpenAPIAuthorizationResponse(response identityport.AuthorizationResponse) openapi.OAuthAuthorizationResponse {
	result := openapi.OAuthAuthorizationResponse{
		AuthorizationUrl: response.AuthorizationURL,
	}
	if response.State != "" {
		result.State = &response.State
	}
	if response.CodeVerifier != "" {
		result.CodeVerifier = &response.CodeVerifier
	}
	if response.CodeChallenge != "" {
		result.CodeChallenge = &response.CodeChallenge
	}
	if response.CodeChallengeMethod != "" {
		method := string(response.CodeChallengeMethod)
		result.CodeChallengeMethod = &method
	}
	return result
}
