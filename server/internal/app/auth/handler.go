package auth

import (
	"net/http"
	"strings"
	"time"

	openapi "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/adapters/inbound/http/openapi"
	sessiondomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/session"
	userdomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/user"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// CookieConfig encapsulates browser cookie attributes enforced by the handler
type CookieConfig struct {
	Domain   string
	Path     string
	Secure   bool
	HTTPOnly bool
	SameSite http.SameSite
}

// Handler exposes authentication endpoints backed by Service
// Use Register to mount the handler on the gin engine generated by oapi-codegen
type Handler struct {
	service *Service
	cookies CookieConfig
}

// NewHandler constructs the HTTP handler
func NewHandler(service *Service, cookies CookieConfig) *Handler {
	if cookies.Path == "" {
		cookies.Path = "/"
	}
	return &Handler{service: service, cookies: cookies}
}

// RegisterUser handles POST /v1/users
func (h *Handler) RegisterUser(c *gin.Context) {
	var payload openapi.RegisterUserRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	result, err := h.service.Register(c.Request.Context(), string(payload.Email), payload.Password)
	if err != nil {
		switch err {
		case ErrEmailAlreadyRegistered:
			c.JSON(http.StatusConflict, gin.H{"error": "email already registered"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "unable to register"})
			return
		}
	}

	c.JSON(http.StatusAccepted, openapi.RegisterUserResponse{ExpiresAt: result.VerificationExpires})
}

// VerifyEmail handles POST /v1/auth/verify
func (h *Handler) VerifyEmail(c *gin.Context) {
	token := strings.TrimSpace(c.Query("token"))
	if token == "" && c.Request.Method != http.MethodGet {
		var payload openapi.VerifyEmailRequest
		if err := c.ShouldBindJSON(&payload); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
			return
		}
		token = strings.TrimSpace(payload.Token)
	}
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
		return
	}

	result, err := h.service.VerifyEmail(c.Request.Context(), token, h.requestMetadata(c))
	if err != nil {
		switch err {
		case ErrVerificationTokenExpired, ErrVerificationTokenUsed:
			c.JSON(http.StatusGone, gin.H{"error": "token invalid"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "verification failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	c.JSON(http.StatusOK, openapi.AuthSessionResponse{User: toOpenAPIUser(result.User)})
}

// Login handles POST /v1/auth/login
func (h *Handler) Login(c *gin.Context) {
	var payload openapi.LoginRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
		return
	}

	result, err := h.service.Login(c.Request.Context(), string(payload.Email), payload.Password, h.requestMetadata(c))
	if err != nil {
		switch err {
		case ErrInvalidCredentials:
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
			return
		case ErrAccountNotVerified:
			c.JSON(http.StatusForbidden, gin.H{"error": "account not verified"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "authentication failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	c.JSON(http.StatusOK, openapi.AuthSessionResponse{User: toOpenAPIUser(result.User)})
}

// Logout handles POST /v1/auth/logout
func (h *Handler) Logout(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		h.clearSessionCookie(c)
		c.Status(http.StatusNoContent)
		return
	}

	if err := h.service.Logout(c.Request.Context(), sessionID); err != nil {
		h.clearSessionCookie(c)
		c.Status(http.StatusNoContent)
		return
	}

	h.clearSessionCookie(c)
	c.Status(http.StatusNoContent)
}

// GetCurrentUser handles GET /v1/auth/me
func (h *Handler) GetCurrentUser(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	h.refreshSessionCookie(c, sess)
	c.JSON(http.StatusOK, openapi.UserResponse{User: toOpenAPIUser(usr)})
}

func (h *Handler) setSessionCookie(c *gin.Context, name string, sess sessiondomain.Session) {
	maxAge := int(time.Until(sess.ExpiresAt).Seconds())
	if maxAge <= 0 {
		maxAge = 0
	}
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(name, sess.ID.String(), maxAge, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) refreshSessionCookie(c *gin.Context, sess sessiondomain.Session) {
	h.setSessionCookie(c, h.service.cfg.CookieName, sess)
}

func (h *Handler) clearSessionCookie(c *gin.Context) {
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(h.service.cfg.CookieName, "", -1, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) sessionIDFromCookie(c *gin.Context) uuid.UUID {
	value, err := c.Cookie(h.service.cfg.CookieName)
	if err != nil {
		return uuid.Nil
	}
	id, err := uuid.Parse(value)
	if err != nil {
		return uuid.Nil
	}
	return id
}

func (h *Handler) requestMetadata(c *gin.Context) Metadata {
	return Metadata{
		ClientIP:  c.ClientIP(),
		UserAgent: c.Request.UserAgent(),
	}
}

func toOpenAPIUser(u userdomain.User) openapi.User {
	return openapi.User{
		Id:          openapi_types.UUID(u.ID),
		Email:       u.Email,
		Status:      string(u.Status),
		CreatedAt:   u.CreatedAt,
		UpdatedAt:   u.UpdatedAt,
		LastLoginAt: u.LastLoginAt,
	}
}
