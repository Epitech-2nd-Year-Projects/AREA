package auth

import (
	"errors"
	"io"
	"net/http"
	"strings"
	"time"

	openapi "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/adapters/inbound/http/openapi"
	sessiondomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/session"
	userdomain "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/domain/user"
	identityport "github.com/Epitech-2nd-Year-Projects/AREA/server/internal/ports/outbound/identity"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// CookieConfig encapsulates browser cookie attributes enforced by the handler
type CookieConfig struct {
	Domain   string
	Path     string
	Secure   bool
	HTTPOnly bool
	SameSite http.SameSite
}

// Handler exposes authentication endpoints backed by Service
// Use Register to mount the handler on the gin engine generated by oapi-codegen
type Handler struct {
	service *Service
	oauth   *OAuthService
	cookies CookieConfig
}

// NewHandler constructs the HTTP handler
func NewHandler(service *Service, oauth *OAuthService, cookies CookieConfig) *Handler {
	if cookies.Path == "" {
		cookies.Path = "/"
	}
	return &Handler{service: service, oauth: oauth, cookies: cookies}
}

// RegisterUser handles POST /v1/users
func (h *Handler) RegisterUser(c *gin.Context) {
	var payload openapi.RegisterUserRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	result, err := h.service.Register(c.Request.Context(), string(payload.Email), payload.Password)
	if err != nil {
		switch err {
		case ErrEmailAlreadyRegistered:
			c.JSON(http.StatusConflict, gin.H{"error": "email already registered"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "unable to register"})
			return
		}
	}

	c.JSON(http.StatusAccepted, openapi.RegisterUserResponse{ExpiresAt: result.VerificationExpires})
}

// VerifyEmail handles POST /v1/auth/verify
func (h *Handler) VerifyEmail(c *gin.Context) {
	token := strings.TrimSpace(c.Query("token"))
	if token == "" && c.Request.Method != http.MethodGet {
		var payload openapi.VerifyEmailRequest
		if err := c.ShouldBindJSON(&payload); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
			return
		}
		token = strings.TrimSpace(payload.Token)
	}
	if token == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "token is required"})
		return
	}

	result, err := h.service.VerifyEmail(c.Request.Context(), token, h.requestMetadata(c))
	if err != nil {
		switch err {
		case ErrVerificationTokenExpired, ErrVerificationTokenUsed:
			c.JSON(http.StatusGone, gin.H{"error": "token invalid"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "verification failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	c.JSON(http.StatusOK, openapi.AuthSessionResponse{User: toOpenAPIUser(result.User)})
}

// Login handles POST /v1/auth/login
func (h *Handler) Login(c *gin.Context) {
	var payload openapi.LoginRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
		return
	}

	result, err := h.service.Login(c.Request.Context(), string(payload.Email), payload.Password, h.requestMetadata(c))
	if err != nil {
		switch err {
		case ErrInvalidCredentials:
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid credentials"})
			return
		case ErrAccountNotVerified:
			c.JSON(http.StatusForbidden, gin.H{"error": "account not verified"})
			return
		default:
			c.JSON(http.StatusBadRequest, gin.H{"error": "authentication failed"})
			return
		}
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	c.JSON(http.StatusOK, openapi.AuthSessionResponse{User: toOpenAPIUser(result.User)})
}

// Logout handles POST /v1/auth/logout
func (h *Handler) Logout(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		h.clearSessionCookie(c)
		c.Status(http.StatusNoContent)
		return
	}

	if err := h.service.Logout(c.Request.Context(), sessionID); err != nil {
		h.clearSessionCookie(c)
		c.Status(http.StatusNoContent)
		return
	}

	h.clearSessionCookie(c)
	c.Status(http.StatusNoContent)
}

// GetCurrentUser handles GET /v1/auth/me
func (h *Handler) GetCurrentUser(c *gin.Context) {
	sessionID := h.sessionIDFromCookie(c)
	if sessionID == uuid.Nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session missing"})
		return
	}

	usr, sess, err := h.service.ResolveSession(c.Request.Context(), sessionID)
	if err != nil {
		h.clearSessionCookie(c)
		c.JSON(http.StatusUnauthorized, gin.H{"error": "session invalid"})
		return
	}

	h.refreshSessionCookie(c, sess)
	c.JSON(http.StatusOK, openapi.UserResponse{User: toOpenAPIUser(usr)})
}

// AuthorizeOAuth handles POST /v1/oauth/{provider}/authorize
func (h *Handler) AuthorizeOAuth(c *gin.Context, provider string) {
	if h.oauth == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	var payload openapi.OAuthAuthorizationRequest
	if err := c.ShouldBindJSON(&payload); err != nil && !errors.Is(err, io.EOF) {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	req := identityport.AuthorizationRequest{
		RedirectURI: stringValue(payload.RedirectUri),
		State:       stringValue(payload.State),
		Prompt:      stringValue(payload.Prompt),
		UsePKCE:     true,
	}
	if payload.UsePkce != nil {
		req.UsePKCE = *payload.UsePkce
	}
	if payload.Scopes != nil {
		req.Scopes = append([]string(nil), (*payload.Scopes)...)
	}

	resp, err := h.oauth.AuthorizationURL(c.Request.Context(), provider, req)
	if err != nil {
		h.handleOAuthError(c, err)
		return
	}

	response := openapi.OAuthAuthorizationResponse{
		AuthorizationUrl: resp.AuthorizationURL,
	}
	if resp.State != "" {
		response.State = &resp.State
	}
	if resp.CodeVerifier != "" {
		response.CodeVerifier = &resp.CodeVerifier
	}
	if resp.CodeChallenge != "" {
		response.CodeChallenge = &resp.CodeChallenge
	}
	if resp.CodeChallengeMethod != "" {
		method := openapi.OAuthAuthorizationResponseCodeChallengeMethod(resp.CodeChallengeMethod)
		response.CodeChallengeMethod = &method
	}

	c.JSON(http.StatusOK, response)
}

// ExchangeOAuth handles POST /v1/oauth/{provider}/exchange
func (h *Handler) ExchangeOAuth(c *gin.Context, provider string) {
	if h.oauth == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "oauth not configured"})
		return
	}

	var payload openapi.OAuthExchangeRequest
	if err := c.ShouldBindJSON(&payload); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request payload"})
		return
	}

	code := strings.TrimSpace(payload.Code)
	if code == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "code is required"})
		return
	}

	req := identityport.ExchangeRequest{
		RedirectURI:  stringValue(payload.RedirectUri),
		CodeVerifier: stringValue(payload.CodeVerifier),
	}

	result, _, err := h.oauth.Exchange(c.Request.Context(), provider, code, req, h.requestMetadata(c))
	if err != nil {
		h.handleOAuthError(c, err)
		return
	}

	h.setSessionCookie(c, result.CookieName, result.Session)
	c.JSON(http.StatusOK, openapi.AuthSessionResponse{User: toOpenAPIUser(result.User)})
}

func (h *Handler) setSessionCookie(c *gin.Context, name string, sess sessiondomain.Session) {
	maxAge := int(time.Until(sess.ExpiresAt).Seconds())
	if maxAge <= 0 {
		maxAge = 0
	}
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(name, sess.ID.String(), maxAge, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) refreshSessionCookie(c *gin.Context, sess sessiondomain.Session) {
	h.setSessionCookie(c, h.service.cfg.CookieName, sess)
}

func (h *Handler) clearSessionCookie(c *gin.Context) {
	c.SetSameSite(h.cookies.SameSite)
	c.SetCookie(h.service.cfg.CookieName, "", -1, h.cookies.Path, h.cookies.Domain, h.cookies.Secure, h.cookies.HTTPOnly)
}

func (h *Handler) sessionIDFromCookie(c *gin.Context) uuid.UUID {
	value, err := c.Cookie(h.service.cfg.CookieName)
	if err != nil {
		return uuid.Nil
	}
	id, err := uuid.Parse(value)
	if err != nil {
		return uuid.Nil
	}
	return id
}

func (h *Handler) requestMetadata(c *gin.Context) Metadata {
	return Metadata{
		ClientIP:  c.ClientIP(),
		UserAgent: c.Request.UserAgent(),
	}
}

func (h *Handler) handleOAuthError(c *gin.Context, err error) {
	switch {
	case err == nil:
		c.Status(http.StatusInternalServerError)
	case errors.Is(err, ErrProviderNotConfigured):
		c.JSON(http.StatusNotFound, gin.H{"error": "provider not configured"})
	case errors.Is(err, ErrOAuthEmailMissing):
		c.JSON(http.StatusBadRequest, gin.H{"error": "email missing from provider"})
	default:
		c.JSON(http.StatusBadGateway, gin.H{"error": "oauth provider error"})
	}
}

func stringValue(value *string) string {
	if value == nil {
		return ""
	}
	return strings.TrimSpace(*value)
}

func toOpenAPIUser(u userdomain.User) openapi.User {
	return openapi.User{
		Id:          openapi_types.UUID(u.ID),
		Email:       u.Email,
		Status:      string(u.Status),
		CreatedAt:   u.CreatedAt,
		UpdatedAt:   u.UpdatedAt,
		LastLoginAt: u.LastLoginAt,
	}
}
